// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.19.1
// source: account.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty, EmptyRequest, Metadata, String } from "./common";

export interface AuthStateChangedRequest {
  metadata?: Metadata | undefined;
  user?: UserInfo | undefined;
}

export interface AuthStateChanged {
  user?: UserInfo | undefined;
}

export interface UserInfo {
  displayName?: string | undefined;
  email?: string | undefined;
  photoUrl?: string | undefined;
}

/** Response containing all user credits data */
export interface UserCreditsData {
  balance?: UserCreditsBalance | undefined;
  usageTransactions: UsageTransaction[];
  paymentTransactions: PaymentTransaction[];
}

/** User's current credit balance */
export interface UserCreditsBalance {
  currentBalance: number;
}

/** Usage transaction record */
export interface UsageTransaction {
  spentAt: string;
  creatorId: string;
  credits: number;
  modelProvider: string;
  model: string;
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
}

/** Payment transaction record */
export interface PaymentTransaction {
  paidAt: string;
  creatorId: string;
  amountCents: number;
  credits: number;
}

function createBaseAuthStateChangedRequest(): AuthStateChangedRequest {
  return { metadata: undefined, user: undefined };
}

export const AuthStateChangedRequest: MessageFns<AuthStateChangedRequest> = {
  encode(message: AuthStateChangedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthStateChangedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthStateChangedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthStateChangedRequest {
    return {
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: AuthStateChangedRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(base?: I): AuthStateChangedRequest {
    return AuthStateChangedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(object: I): AuthStateChangedRequest {
    const message = createBaseAuthStateChangedRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseAuthStateChanged(): AuthStateChanged {
  return { user: undefined };
}

export const AuthStateChanged: MessageFns<AuthStateChanged> = {
  encode(message: AuthStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthStateChanged {
    return { user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined };
  },

  toJSON(message: AuthStateChanged): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthStateChanged>, I>>(base?: I): AuthStateChanged {
    return AuthStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthStateChanged>, I>>(object: I): AuthStateChanged {
    const message = createBaseAuthStateChanged();
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { displayName: undefined, email: undefined, photoUrl: undefined };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== undefined) {
      writer.uint32(10).string(message.displayName);
    }
    if (message.email !== undefined) {
      writer.uint32(18).string(message.email);
    }
    if (message.photoUrl !== undefined) {
      writer.uint32(26).string(message.photoUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.photoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      photoUrl: isSet(object.photoUrl) ? globalThis.String(object.photoUrl) : undefined,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.photoUrl !== undefined) {
      obj.photoUrl = message.photoUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.displayName = object.displayName ?? undefined;
    message.email = object.email ?? undefined;
    message.photoUrl = object.photoUrl ?? undefined;
    return message;
  },
};

function createBaseUserCreditsData(): UserCreditsData {
  return { balance: undefined, usageTransactions: [], paymentTransactions: [] };
}

export const UserCreditsData: MessageFns<UserCreditsData> = {
  encode(message: UserCreditsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== undefined) {
      UserCreditsBalance.encode(message.balance, writer.uint32(10).fork()).join();
    }
    for (const v of message.usageTransactions) {
      UsageTransaction.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.paymentTransactions) {
      PaymentTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCreditsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCreditsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = UserCreditsBalance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.usageTransactions.push(UsageTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentTransactions.push(PaymentTransaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCreditsData {
    return {
      balance: isSet(object.balance) ? UserCreditsBalance.fromJSON(object.balance) : undefined,
      usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
        ? object.usageTransactions.map((e: any) => UsageTransaction.fromJSON(e))
        : [],
      paymentTransactions: globalThis.Array.isArray(object?.paymentTransactions)
        ? object.paymentTransactions.map((e: any) => PaymentTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserCreditsData): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = UserCreditsBalance.toJSON(message.balance);
    }
    if (message.usageTransactions?.length) {
      obj.usageTransactions = message.usageTransactions.map((e) => UsageTransaction.toJSON(e));
    }
    if (message.paymentTransactions?.length) {
      obj.paymentTransactions = message.paymentTransactions.map((e) => PaymentTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCreditsData>, I>>(base?: I): UserCreditsData {
    return UserCreditsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCreditsData>, I>>(object: I): UserCreditsData {
    const message = createBaseUserCreditsData();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? UserCreditsBalance.fromPartial(object.balance)
      : undefined;
    message.usageTransactions = object.usageTransactions?.map((e) => UsageTransaction.fromPartial(e)) || [];
    message.paymentTransactions = object.paymentTransactions?.map((e) => PaymentTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserCreditsBalance(): UserCreditsBalance {
  return { currentBalance: 0 };
}

export const UserCreditsBalance: MessageFns<UserCreditsBalance> = {
  encode(message: UserCreditsBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentBalance !== 0) {
      writer.uint32(9).double(message.currentBalance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCreditsBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCreditsBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.currentBalance = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCreditsBalance {
    return { currentBalance: isSet(object.currentBalance) ? globalThis.Number(object.currentBalance) : 0 };
  },

  toJSON(message: UserCreditsBalance): unknown {
    const obj: any = {};
    if (message.currentBalance !== 0) {
      obj.currentBalance = message.currentBalance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCreditsBalance>, I>>(base?: I): UserCreditsBalance {
    return UserCreditsBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCreditsBalance>, I>>(object: I): UserCreditsBalance {
    const message = createBaseUserCreditsBalance();
    message.currentBalance = object.currentBalance ?? 0;
    return message;
  },
};

function createBaseUsageTransaction(): UsageTransaction {
  return {
    spentAt: "",
    creatorId: "",
    credits: 0,
    modelProvider: "",
    model: "",
    promptTokens: 0,
    completionTokens: 0,
    totalTokens: 0,
  };
}

export const UsageTransaction: MessageFns<UsageTransaction> = {
  encode(message: UsageTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spentAt !== "") {
      writer.uint32(10).string(message.spentAt);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    if (message.credits !== 0) {
      writer.uint32(25).double(message.credits);
    }
    if (message.modelProvider !== "") {
      writer.uint32(34).string(message.modelProvider);
    }
    if (message.model !== "") {
      writer.uint32(42).string(message.model);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(48).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(56).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(64).int32(message.totalTokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsageTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsageTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spentAt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.credits = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modelProvider = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsageTransaction {
    return {
      spentAt: isSet(object.spentAt) ? globalThis.String(object.spentAt) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      credits: isSet(object.credits) ? globalThis.Number(object.credits) : 0,
      modelProvider: isSet(object.modelProvider) ? globalThis.String(object.modelProvider) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
    };
  },

  toJSON(message: UsageTransaction): unknown {
    const obj: any = {};
    if (message.spentAt !== "") {
      obj.spentAt = message.spentAt;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.credits !== 0) {
      obj.credits = message.credits;
    }
    if (message.modelProvider !== "") {
      obj.modelProvider = message.modelProvider;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsageTransaction>, I>>(base?: I): UsageTransaction {
    return UsageTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsageTransaction>, I>>(object: I): UsageTransaction {
    const message = createBaseUsageTransaction();
    message.spentAt = object.spentAt ?? "";
    message.creatorId = object.creatorId ?? "";
    message.credits = object.credits ?? 0;
    message.modelProvider = object.modelProvider ?? "";
    message.model = object.model ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    return message;
  },
};

function createBasePaymentTransaction(): PaymentTransaction {
  return { paidAt: "", creatorId: "", amountCents: 0, credits: 0 };
}

export const PaymentTransaction: MessageFns<PaymentTransaction> = {
  encode(message: PaymentTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paidAt !== "") {
      writer.uint32(10).string(message.paidAt);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int32(message.amountCents);
    }
    if (message.credits !== 0) {
      writer.uint32(33).double(message.credits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.credits = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentTransaction {
    return {
      paidAt: isSet(object.paidAt) ? globalThis.String(object.paidAt) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
      credits: isSet(object.credits) ? globalThis.Number(object.credits) : 0,
    };
  },

  toJSON(message: PaymentTransaction): unknown {
    const obj: any = {};
    if (message.paidAt !== "") {
      obj.paidAt = message.paidAt;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.credits !== 0) {
      obj.credits = message.credits;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentTransaction>, I>>(base?: I): PaymentTransaction {
    return PaymentTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentTransaction>, I>>(object: I): PaymentTransaction {
    const message = createBasePaymentTransaction();
    message.paidAt = object.paidAt ?? "";
    message.creatorId = object.creatorId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.credits = object.credits ?? 0;
    return message;
  },
};

/** Service for account-related operations */
export type AccountServiceDefinition = typeof AccountServiceDefinition;
export const AccountServiceDefinition = {
  name: "AccountService",
  fullName: "clineChinese.AccountService",
  methods: {
    /**
     * Handles the user clicking the login link in the UI.
     * Generates a secure nonce for state validation, stores it in secrets,
     * and opens the authentication URL in the external browser.
     */
    accountLoginClicked: {
      name: "accountLoginClicked",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: String,
      responseStream: false,
      options: {},
    },
    /**
     * Handles the user clicking the logout button in the UI.
     * Clears API keys and user state.
     */
    accountLogoutClicked: {
      name: "accountLogoutClicked",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Subscribe to auth callback events (when authentication tokens are received) */
    subscribeToAuthCallback: {
      name: "subscribeToAuthCallback",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: String,
      responseStream: true,
      options: {},
    },
    /**
     * Handles authentication state changes from the Firebase context.
     * Updates the user info in global state and returns the updated value.
     */
    authStateChanged: {
      name: "authStateChanged",
      requestType: AuthStateChangedRequest,
      requestStream: false,
      responseType: AuthStateChanged,
      responseStream: false,
      options: {},
    },
    /** Fetches all user credits data (balance, usage transactions, payment transactions) */
    fetchUserCreditsData: {
      name: "fetchUserCreditsData",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: UserCreditsData,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
